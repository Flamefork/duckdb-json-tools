# name: test/sql/json_flatten.test
# description: json_flatten flattens nested JSON structures using dotted keys and covers edge cases
# group: [sql]

require json_tools

# Ensure helper constructors from the json extension are available
require json

# ========================================
# Basic Behavior Tests
# ========================================

query I
SELECT json_flatten('{"a": 1, "b": {"c": 2}}');
----
{"a":1,"b.c":2}

query I
SELECT json_flatten('{"x": 1, "y": 2}');
----
{"x":1,"y":2}

query I
SELECT json_flatten('{"a": {"b": {"c": {"d": 4}}}}');
----
{"a.b.c.d":4}

query I
SELECT json_flatten('{"a": [1, {"b": 2}, [3, 4]]}');
----
{"a.0":1,"a.1.b":2,"a.2.0":3,"a.2.1":4}

query I
SELECT json_flatten(NULL);
----
NULL

query I
SELECT json_flatten('{"": 1}');
----
{"":1}

statement error
SELECT json_flatten('{');
----
Conversion Error: Malformed JSON at byte 1 of input: unexpected end of data.  Input: "{"

# ========================================
# Parser Flag Alignment Tests
# ========================================

query I
SELECT json_flatten('{"a":1,}');
----
{"a":1}

query I
SELECT lower(json_flatten('{"a":NaN}')::VARCHAR) LIKE '%nan%' AS ok;
----
true

query I
SELECT lower(json_flatten('{"a":Infinity}')::VARCHAR) LIKE '%inf%' AS ok;
----
true

query I
SELECT json_flatten('{"a":18446744073709551616}')::VARCHAR LIKE '%18446744073709551616%' AS ok;
----
true

query I
SELECT lower(json_flatten('{"a":18446744073709551616}')::VARCHAR) NOT LIKE '%e%' AS ok;
----
true

# ========================================
# Unicode Support Tests
# ========================================

query I
SELECT json_flatten('{"‰∏≠Êñá": 1, "Êó•Êú¨Ë™û": 2, "ÌïúÍµ≠Ïñ¥": 3}');
----
{"‰∏≠Êñá":1,"Êó•Êú¨Ë™û":2,"ÌïúÍµ≠Ïñ¥":3}

query I
SELECT json_flatten('{"üî•": "fire", "üöÄ": "rocket"}');
----
{"üî•":"fire","üöÄ":"rocket"}

query I
SELECT json_flatten('{"–†—É—Å—Å–∫–∏–π": "—Ç–µ–∫—Å—Ç"}');
----
{"–†—É—Å—Å–∫–∏–π":"—Ç–µ–∫—Å—Ç"}

query I
SELECT json_flatten('{"ÿßŸÑÿπÿ±ÿ®Ÿäÿ©": 42}');
----
{"ÿßŸÑÿπÿ±ÿ®Ÿäÿ©":42}

query I
SELECT json_flatten('{"outer": {"Êó•Êú¨Ë™û": {"inner": 1}}}');
----
{"outer.Êó•Êú¨Ë™û.inner":1}

query I
SELECT json_flatten('{"name": "Jos√© Garc√≠a"}');
----
{"name":"Jos√© Garc√≠a"}

query I
SELECT json_flatten('{"user": {"bio": "Engineer üë®‚Äçüíª"}}');
----
{"user.bio":"Engineer üë®‚Äçüíª"}

query I
SELECT json_flatten('{"english": 1, "Êó•Êú¨Ë™û": 2, "mixed_Ëã±Ë™û": 3}');
----
{"english":1,"Êó•Êú¨Ë™û":2,"mixed_Ëã±Ë™û":3}

query I
SELECT json_flatten('{"items": [{"ÂêçÂâç": "Áî∞‰∏≠"}]}');
----
{"items.0.ÂêçÂâç":"Áî∞‰∏≠"}

query I
SELECT json_flatten('{"": "UnicodeÂÄ§"}');
----
{"":"UnicodeÂÄ§"}

# ========================================
# Empty Container Tests
# ========================================

query I
SELECT json_flatten('{}');
----
{}

query I
SELECT json_flatten('[]');
----
{}

query I
SELECT json_flatten('{"a": {}, "b": 1}');
----
{"b":1}

query I
SELECT json_flatten('{"items": [], "count": 0}');
----
{"count":0}

query I
SELECT json_flatten('{"empty_obj": {}, "empty_arr": [], "data": {"x": 1}}');
----
{"data.x":1}

query I
SELECT json_flatten('{"outer": {"inner": {}}}');
----
{}

query I
SELECT json_flatten('{"a": {"b": [], "c": 2}}');
----
{"a.c":2}

query I
SELECT json_flatten('{"": {}}');
----
{}

# ========================================
# Large Array Index Tests
# ========================================

query I
WITH large AS (
    SELECT json_flatten(json_object('arr', json_group_array(i))) AS flat
    FROM range(0, 1000) t(i)
)
SELECT flat::VARCHAR LIKE '%"arr.0":0%' AND flat::VARCHAR LIKE '%"arr.999":999%' AS valid
FROM large;
----
true

query I
WITH large AS (
    SELECT json_flatten(json_object('arr', json_group_array(i))) AS flat
    FROM range(0, 10000) t(i)
)
SELECT flat::VARCHAR LIKE '%"arr.9999":9999%' AS valid
FROM large;
----
true

query I
WITH large AS (
    SELECT json_flatten(json_object('arr', json_group_array(i))) AS flat
    FROM range(0, 100000) t(i)
)
SELECT flat::VARCHAR LIKE '%"arr.99999":99999%' AS valid
FROM large;
----
true

query I
WITH sparse AS (
    SELECT json_flatten(json_group_array(CASE WHEN i = 999 THEN 'val999' ELSE NULL END)) AS flat
    FROM range(0, 1000) t(i)
)
SELECT flat::VARCHAR LIKE '%"999":"val999"%' AS valid
FROM sparse;
----
true

query I
SELECT json_flatten('{"a": [0,1,2,3,4,5,6,7,8,9,10]}');
----
{"a.0":0,"a.1":1,"a.2":2,"a.3":3,"a.4":4,"a.5":5,"a.6":6,"a.7":7,"a.8":8,"a.9":9,"a.10":10}

# ========================================
# Deeply Nested Array Tests
# ========================================

query I
SELECT json_flatten('[[1, 2], [3, 4]]');
----
{"0.0":1,"0.1":2,"1.0":3,"1.1":4}

query I
SELECT json_flatten('[[[1, 2]]]');
----
{"0.0.0":1,"0.0.1":2}

query I
SELECT json_flatten('[[[[[[42]]]]]]');
----
{"0.0.0.0.0.0":42}

query I
SELECT json_flatten('[{"a": [{"b": 1}]}]');
----
{"0.a.0.b":1}

# ========================================
# Custom Separator Tests
# ========================================

query I
SELECT json_flatten('{"a": 1, "b": {"c": 2}, "d": [3, {"e": 4}]}', '/');
----
{"a":1,"b/c":2,"d/0":3,"d/1/e":4}

query I
SELECT json_flatten('[[1, 2], [3, 4]]', '_');
----
{"0_0":1,"0_1":2,"1_0":3,"1_1":4}

statement error
SELECT json_flatten('{"a": 1}', '');
----
Binder Error: json_flatten separator must be a VARCHAR literal of length 1

statement error
SELECT json_flatten('{"a": 1}', '__');
----
Binder Error: json_flatten separator must be a VARCHAR literal of length 1

statement error
SELECT json_flatten('{"a": 1}', sep) FROM (VALUES ('/')) t(sep);
----
Binder Error: json_flatten separator argument must be constant
